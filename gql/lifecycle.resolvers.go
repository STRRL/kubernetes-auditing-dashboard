package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"

	"github.com/strrl/kubernetes-auditing-dashboard/ent"
	"github.com/strrl/kubernetes-auditing-dashboard/ent/auditevent"
	"github.com/strrl/kubernetes-auditing-dashboard/pkg/services/lifecycle"
	"k8s.io/apiserver/pkg/apis/audit"
	"sigs.k8s.io/yaml"
)

// ResourceLifecycle is the resolver for the resourceLifecycle field.
func (r *queryResolver) ResourceLifecycle(ctx context.Context, apiGroup string, version string, kind string, namespace *string, name string) ([]*LifecycleEvent, error) {
	// Parse the input into ResourceIdentifier
	gvk := fmt.Sprintf("%s-%s-%s", apiGroup, version, kind)
	if apiGroup == "" {
		gvk = fmt.Sprintf("%s-%s", version, kind)
	}

	namespaceStr := ""
	if namespace != nil {
		namespaceStr = *namespace
	}

	ri, err := lifecycle.ParseFromURL(gvk, namespaceStr, name)
	if err != nil {
		return nil, lifecycle.NewValidationError("input", err.Error())
	}

	// Convert to Ent query parameters
	apiGroupQuery, apiVersionQuery, resourceQuery, namespaceQuery, nameQuery := ri.ToEntQuery()

	// Query audit events from the database
	// Include all verbs: get, create, update, patch, delete
	// Only include ResponseComplete stage to ensure we have full resource state for diff calculation
	query := r.entClient.AuditEvent.Query().
		Where(
			auditevent.ApiGroupEQ(apiGroupQuery),
			auditevent.ApiVersionEQ(apiVersionQuery),
			auditevent.ResourceEQ(resourceQuery),
			auditevent.NamespaceEQ(namespaceQuery),
			auditevent.NameEQ(nameQuery),
			auditevent.VerbIn("get", "create", "update", "patch", "delete"),
			auditevent.StageEQ("ResponseComplete"),
		)

	// Order by requestTimestamp DESC (newest first)
	query = query.Order(ent.Desc(auditevent.FieldRequestTimestamp))

	// Execute query
	events, err := query.All(ctx)
	if err != nil {
		return nil, lifecycle.NewDatabaseError("query", "resourceLifecycle", err)
	}

	// Handle no events found
	if len(events) == 0 {
		return []*LifecycleEvent{}, nil
	}

	// Convert to lifecycle events
	lifecycleEvents := make([]*LifecycleEvent, 0, len(events))

	// Create a map to track resource states for diff calculation
	resourceStates := make(map[int]map[string]interface{})

	// First pass: parse all events and extract resource states
	for _, event := range events {
		// Parse the raw audit event
		var auditEvent audit.Event
		if err := json.Unmarshal([]byte(event.Raw), &auditEvent); err != nil {
			continue // Skip malformed events
		}

		// Extract resource state from request or response object
		var resourceState map[string]interface{}
		if auditEvent.ResponseObject != nil && auditEvent.ResponseObject.Raw != nil {
			if err := json.Unmarshal(auditEvent.ResponseObject.Raw, &resourceState); err == nil {
				// Filter out error responses (Status objects) and mismatched kinds
				if responseKind, ok := resourceState["kind"].(string); ok {
					if responseKind != kind {
						continue
					}
				}
				resourceStates[event.ID] = resourceState
			}
		} else if auditEvent.RequestObject != nil && auditEvent.RequestObject.Raw != nil {
			if err := json.Unmarshal(auditEvent.RequestObject.Raw, &resourceState); err == nil {
				// Filter out error responses (Status objects) and mismatched kinds
				if requestKind, ok := resourceState["kind"].(string); ok {
					if requestKind != kind {
						continue
					}
				}
				resourceStates[event.ID] = resourceState
			}
		}
	}

	// Second pass: create lifecycle events with diffs
	for i, event := range events {
		// Parse the raw audit event
		var auditEvent audit.Event
		if err := json.Unmarshal([]byte(event.Raw), &auditEvent); err != nil {
			continue // Skip malformed events
		}

		// Map verb to event type
		lifecycleEventType := lifecycle.MapVerbToEventType(event.Verb)

		// Convert lifecycle.EventType to gql.EventType
		var gqlEventType EventType
		switch lifecycleEventType {
		case lifecycle.EventTypeCreate:
			gqlEventType = EventTypeCreate
		case lifecycle.EventTypeUpdate:
			gqlEventType = EventTypeUpdate
		case lifecycle.EventTypeDelete:
			gqlEventType = EventTypeDelete
		case lifecycle.EventTypeGet:
			gqlEventType = EventTypeGet
		default:
			gqlEventType = EventTypeUpdate
		}

		// For UPDATE/PATCH events, require both requestObject and responseObject for meaningful diff
		if gqlEventType == EventTypeUpdate {
			hasRequest := auditEvent.RequestObject != nil && auditEvent.RequestObject.Raw != nil
			hasResponse := auditEvent.ResponseObject != nil && auditEvent.ResponseObject.Raw != nil
			if !hasRequest && !hasResponse {
				continue
			}
		}

		// Get user from audit event
		user := "unknown"
		if auditEvent.User.Username != "" {
			user = auditEvent.User.Username
		}

		// Get current resource state
		currentState, hasCurrentState := resourceStates[event.ID]

		// Skip events without valid resource state (error responses, filtered kinds)
		if !hasCurrentState {
			continue
		}

		// Convert resource state to YAML then to JSON string
		var resourceStateJSON string
		if hasCurrentState {
			yamlBytes, err := yaml.Marshal(currentState)
			if err == nil {
				// Convert YAML to JSON string for GraphQL
				var jsonObj interface{}
				if err := yaml.Unmarshal(yamlBytes, &jsonObj); err == nil {
					jsonBytes, err := json.Marshal(jsonObj)
					if err == nil {
						resourceStateJSON = string(jsonBytes)
					}
				}
			}
		}

		// Create lifecycle event
		lifecycleEvent := &LifecycleEvent{
			ID:            event.ID,
			Type:          gqlEventType,
			Timestamp:     event.RequestTimestamp,
			User:          user,
			ResourceState: resourceStateJSON,
		}

		// Calculate diff and previousState for UPDATE events (not for CREATE or DELETE)
		if gqlEventType == EventTypeUpdate && i < len(events)-1 {
			// Find previous mutating event (skip GET/LIST/WATCH events)
			var prevState map[string]interface{}
			var hasPrevState bool
			for j := i + 1; j < len(events); j++ {
				prevEventType := lifecycle.MapVerbToEventType(events[j].Verb)
				// Only use CREATE/UPDATE/DELETE events as previous state
				if prevEventType == lifecycle.EventTypeCreate ||
					prevEventType == lifecycle.EventTypeUpdate ||
					prevEventType == lifecycle.EventTypeDelete {
					prevState, hasPrevState = resourceStates[events[j].ID]
					break
				}
			}

			if hasPrevState && hasCurrentState {
				// Convert previous state to JSON string
				var previousStateJSON string
				yamlBytes, err := yaml.Marshal(prevState)
				if err == nil {
					var jsonObj interface{}
					if err := yaml.Unmarshal(yamlBytes, &jsonObj); err == nil {
						jsonBytes, err := json.Marshal(jsonObj)
						if err == nil {
							previousStateJSON = string(jsonBytes)
							lifecycleEvent.PreviousState = &previousStateJSON
						}
					}
				}

				// Convert states to YAML for diff calculation
				prevYAML, _ := yaml.Marshal(prevState)
				currentYAML, _ := yaml.Marshal(currentState)

				// Compute diff
				diff, err := lifecycle.ComputeDiff(string(prevYAML), string(currentYAML))
				if err == nil && diff != nil {
					// Convert diff to GraphQL format
					gqlDiff := &ResourceDiff{
						Modified: make([]*DiffEntry, 0),
					}

					// Convert added fields
					if len(diff.Added) > 0 {
						addedJSON, _ := json.Marshal(diff.Added)
						addedStr := string(addedJSON)
						gqlDiff.Added = &addedStr
					}

					// Convert removed fields
					if len(diff.Removed) > 0 {
						removedJSON, _ := json.Marshal(diff.Removed)
						removedStr := string(removedJSON)
						gqlDiff.Removed = &removedStr
					}

					// Convert modified fields
					for path, entry := range diff.Modified {
						oldJSON, _ := json.Marshal(entry.OldValue)
						newJSON, _ := json.Marshal(entry.NewValue)

						gqlDiff.Modified = append(gqlDiff.Modified, &DiffEntry{
							Path:     path,
							OldValue: string(oldJSON),
							NewValue: string(newJSON),
						})
					}

					// Sort modified entries by path for consistent output
					sort.Slice(gqlDiff.Modified, func(i, j int) bool {
						return gqlDiff.Modified[i].Path < gqlDiff.Modified[j].Path
					})

					lifecycleEvent.Diff = gqlDiff
				}
			}
		}

		lifecycleEvents = append(lifecycleEvents, lifecycleEvent)
	}

	return lifecycleEvents, nil
}

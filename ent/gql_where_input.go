// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/strrl/kubernetes-auditing-dashboard/ent/auditevent"
	"github.com/strrl/kubernetes-auditing-dashboard/ent/predicate"
	"github.com/strrl/kubernetes-auditing-dashboard/ent/resourcekind"
	"github.com/strrl/kubernetes-auditing-dashboard/ent/view"
)

// AuditEventWhereInput represents a where input for filtering AuditEvent queries.
type AuditEventWhereInput struct {
	Predicates []predicate.AuditEvent  `json:"-"`
	Not        *AuditEventWhereInput   `json:"not,omitempty"`
	Or         []*AuditEventWhereInput `json:"or,omitempty"`
	And        []*AuditEventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "raw" field predicates.
	Raw             *string  `json:"raw,omitempty"`
	RawNEQ          *string  `json:"rawNEQ,omitempty"`
	RawIn           []string `json:"rawIn,omitempty"`
	RawNotIn        []string `json:"rawNotIn,omitempty"`
	RawGT           *string  `json:"rawGT,omitempty"`
	RawGTE          *string  `json:"rawGTE,omitempty"`
	RawLT           *string  `json:"rawLT,omitempty"`
	RawLTE          *string  `json:"rawLTE,omitempty"`
	RawContains     *string  `json:"rawContains,omitempty"`
	RawHasPrefix    *string  `json:"rawHasPrefix,omitempty"`
	RawHasSuffix    *string  `json:"rawHasSuffix,omitempty"`
	RawEqualFold    *string  `json:"rawEqualFold,omitempty"`
	RawContainsFold *string  `json:"rawContainsFold,omitempty"`

	// "level" field predicates.
	Level             *string  `json:"level,omitempty"`
	LevelNEQ          *string  `json:"levelNEQ,omitempty"`
	LevelIn           []string `json:"levelIn,omitempty"`
	LevelNotIn        []string `json:"levelNotIn,omitempty"`
	LevelGT           *string  `json:"levelGT,omitempty"`
	LevelGTE          *string  `json:"levelGTE,omitempty"`
	LevelLT           *string  `json:"levelLT,omitempty"`
	LevelLTE          *string  `json:"levelLTE,omitempty"`
	LevelContains     *string  `json:"levelContains,omitempty"`
	LevelHasPrefix    *string  `json:"levelHasPrefix,omitempty"`
	LevelHasSuffix    *string  `json:"levelHasSuffix,omitempty"`
	LevelEqualFold    *string  `json:"levelEqualFold,omitempty"`
	LevelContainsFold *string  `json:"levelContainsFold,omitempty"`

	// "auditID" field predicates.
	AuditID             *string  `json:"auditid,omitempty"`
	AuditIDNEQ          *string  `json:"auditidNEQ,omitempty"`
	AuditIDIn           []string `json:"auditidIn,omitempty"`
	AuditIDNotIn        []string `json:"auditidNotIn,omitempty"`
	AuditIDGT           *string  `json:"auditidGT,omitempty"`
	AuditIDGTE          *string  `json:"auditidGTE,omitempty"`
	AuditIDLT           *string  `json:"auditidLT,omitempty"`
	AuditIDLTE          *string  `json:"auditidLTE,omitempty"`
	AuditIDContains     *string  `json:"auditidContains,omitempty"`
	AuditIDHasPrefix    *string  `json:"auditidHasPrefix,omitempty"`
	AuditIDHasSuffix    *string  `json:"auditidHasSuffix,omitempty"`
	AuditIDEqualFold    *string  `json:"auditidEqualFold,omitempty"`
	AuditIDContainsFold *string  `json:"auditidContainsFold,omitempty"`

	// "verb" field predicates.
	Verb             *string  `json:"verb,omitempty"`
	VerbNEQ          *string  `json:"verbNEQ,omitempty"`
	VerbIn           []string `json:"verbIn,omitempty"`
	VerbNotIn        []string `json:"verbNotIn,omitempty"`
	VerbGT           *string  `json:"verbGT,omitempty"`
	VerbGTE          *string  `json:"verbGTE,omitempty"`
	VerbLT           *string  `json:"verbLT,omitempty"`
	VerbLTE          *string  `json:"verbLTE,omitempty"`
	VerbContains     *string  `json:"verbContains,omitempty"`
	VerbHasPrefix    *string  `json:"verbHasPrefix,omitempty"`
	VerbHasSuffix    *string  `json:"verbHasSuffix,omitempty"`
	VerbEqualFold    *string  `json:"verbEqualFold,omitempty"`
	VerbContainsFold *string  `json:"verbContainsFold,omitempty"`

	// "userAgent" field predicates.
	UserAgent             *string  `json:"useragent,omitempty"`
	UserAgentNEQ          *string  `json:"useragentNEQ,omitempty"`
	UserAgentIn           []string `json:"useragentIn,omitempty"`
	UserAgentNotIn        []string `json:"useragentNotIn,omitempty"`
	UserAgentGT           *string  `json:"useragentGT,omitempty"`
	UserAgentGTE          *string  `json:"useragentGTE,omitempty"`
	UserAgentLT           *string  `json:"useragentLT,omitempty"`
	UserAgentLTE          *string  `json:"useragentLTE,omitempty"`
	UserAgentContains     *string  `json:"useragentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"useragentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"useragentHasSuffix,omitempty"`
	UserAgentEqualFold    *string  `json:"useragentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"useragentContainsFold,omitempty"`

	// "requestTimestamp" field predicates.
	RequestTimestamp      *time.Time  `json:"requesttimestamp,omitempty"`
	RequestTimestampNEQ   *time.Time  `json:"requesttimestampNEQ,omitempty"`
	RequestTimestampIn    []time.Time `json:"requesttimestampIn,omitempty"`
	RequestTimestampNotIn []time.Time `json:"requesttimestampNotIn,omitempty"`
	RequestTimestampGT    *time.Time  `json:"requesttimestampGT,omitempty"`
	RequestTimestampGTE   *time.Time  `json:"requesttimestampGTE,omitempty"`
	RequestTimestampLT    *time.Time  `json:"requesttimestampLT,omitempty"`
	RequestTimestampLTE   *time.Time  `json:"requesttimestampLTE,omitempty"`

	// "stageTimestamp" field predicates.
	StageTimestamp      *time.Time  `json:"stagetimestamp,omitempty"`
	StageTimestampNEQ   *time.Time  `json:"stagetimestampNEQ,omitempty"`
	StageTimestampIn    []time.Time `json:"stagetimestampIn,omitempty"`
	StageTimestampNotIn []time.Time `json:"stagetimestampNotIn,omitempty"`
	StageTimestampGT    *time.Time  `json:"stagetimestampGT,omitempty"`
	StageTimestampGTE   *time.Time  `json:"stagetimestampGTE,omitempty"`
	StageTimestampLT    *time.Time  `json:"stagetimestampLT,omitempty"`
	StageTimestampLTE   *time.Time  `json:"stagetimestampLTE,omitempty"`

	// "namespace" field predicates.
	Namespace             *string  `json:"namespace,omitempty"`
	NamespaceNEQ          *string  `json:"namespaceNEQ,omitempty"`
	NamespaceIn           []string `json:"namespaceIn,omitempty"`
	NamespaceNotIn        []string `json:"namespaceNotIn,omitempty"`
	NamespaceGT           *string  `json:"namespaceGT,omitempty"`
	NamespaceGTE          *string  `json:"namespaceGTE,omitempty"`
	NamespaceLT           *string  `json:"namespaceLT,omitempty"`
	NamespaceLTE          *string  `json:"namespaceLTE,omitempty"`
	NamespaceContains     *string  `json:"namespaceContains,omitempty"`
	NamespaceHasPrefix    *string  `json:"namespaceHasPrefix,omitempty"`
	NamespaceHasSuffix    *string  `json:"namespaceHasSuffix,omitempty"`
	NamespaceEqualFold    *string  `json:"namespaceEqualFold,omitempty"`
	NamespaceContainsFold *string  `json:"namespaceContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "apiVersion" field predicates.
	ApiVersion             *string  `json:"apiversion,omitempty"`
	ApiVersionNEQ          *string  `json:"apiversionNEQ,omitempty"`
	ApiVersionIn           []string `json:"apiversionIn,omitempty"`
	ApiVersionNotIn        []string `json:"apiversionNotIn,omitempty"`
	ApiVersionGT           *string  `json:"apiversionGT,omitempty"`
	ApiVersionGTE          *string  `json:"apiversionGTE,omitempty"`
	ApiVersionLT           *string  `json:"apiversionLT,omitempty"`
	ApiVersionLTE          *string  `json:"apiversionLTE,omitempty"`
	ApiVersionContains     *string  `json:"apiversionContains,omitempty"`
	ApiVersionHasPrefix    *string  `json:"apiversionHasPrefix,omitempty"`
	ApiVersionHasSuffix    *string  `json:"apiversionHasSuffix,omitempty"`
	ApiVersionEqualFold    *string  `json:"apiversionEqualFold,omitempty"`
	ApiVersionContainsFold *string  `json:"apiversionContainsFold,omitempty"`

	// "apiGroup" field predicates.
	ApiGroup             *string  `json:"apigroup,omitempty"`
	ApiGroupNEQ          *string  `json:"apigroupNEQ,omitempty"`
	ApiGroupIn           []string `json:"apigroupIn,omitempty"`
	ApiGroupNotIn        []string `json:"apigroupNotIn,omitempty"`
	ApiGroupGT           *string  `json:"apigroupGT,omitempty"`
	ApiGroupGTE          *string  `json:"apigroupGTE,omitempty"`
	ApiGroupLT           *string  `json:"apigroupLT,omitempty"`
	ApiGroupLTE          *string  `json:"apigroupLTE,omitempty"`
	ApiGroupContains     *string  `json:"apigroupContains,omitempty"`
	ApiGroupHasPrefix    *string  `json:"apigroupHasPrefix,omitempty"`
	ApiGroupHasSuffix    *string  `json:"apigroupHasSuffix,omitempty"`
	ApiGroupEqualFold    *string  `json:"apigroupEqualFold,omitempty"`
	ApiGroupContainsFold *string  `json:"apigroupContainsFold,omitempty"`

	// "resource" field predicates.
	Resource             *string  `json:"resource,omitempty"`
	ResourceNEQ          *string  `json:"resourceNEQ,omitempty"`
	ResourceIn           []string `json:"resourceIn,omitempty"`
	ResourceNotIn        []string `json:"resourceNotIn,omitempty"`
	ResourceGT           *string  `json:"resourceGT,omitempty"`
	ResourceGTE          *string  `json:"resourceGTE,omitempty"`
	ResourceLT           *string  `json:"resourceLT,omitempty"`
	ResourceLTE          *string  `json:"resourceLTE,omitempty"`
	ResourceContains     *string  `json:"resourceContains,omitempty"`
	ResourceHasPrefix    *string  `json:"resourceHasPrefix,omitempty"`
	ResourceHasSuffix    *string  `json:"resourceHasSuffix,omitempty"`
	ResourceEqualFold    *string  `json:"resourceEqualFold,omitempty"`
	ResourceContainsFold *string  `json:"resourceContainsFold,omitempty"`

	// "subResource" field predicates.
	SubResource             *string  `json:"subresource,omitempty"`
	SubResourceNEQ          *string  `json:"subresourceNEQ,omitempty"`
	SubResourceIn           []string `json:"subresourceIn,omitempty"`
	SubResourceNotIn        []string `json:"subresourceNotIn,omitempty"`
	SubResourceGT           *string  `json:"subresourceGT,omitempty"`
	SubResourceGTE          *string  `json:"subresourceGTE,omitempty"`
	SubResourceLT           *string  `json:"subresourceLT,omitempty"`
	SubResourceLTE          *string  `json:"subresourceLTE,omitempty"`
	SubResourceContains     *string  `json:"subresourceContains,omitempty"`
	SubResourceHasPrefix    *string  `json:"subresourceHasPrefix,omitempty"`
	SubResourceHasSuffix    *string  `json:"subresourceHasSuffix,omitempty"`
	SubResourceEqualFold    *string  `json:"subresourceEqualFold,omitempty"`
	SubResourceContainsFold *string  `json:"subresourceContainsFold,omitempty"`

	// "stage" field predicates.
	Stage             *string  `json:"stage,omitempty"`
	StageNEQ          *string  `json:"stageNEQ,omitempty"`
	StageIn           []string `json:"stageIn,omitempty"`
	StageNotIn        []string `json:"stageNotIn,omitempty"`
	StageGT           *string  `json:"stageGT,omitempty"`
	StageGTE          *string  `json:"stageGTE,omitempty"`
	StageLT           *string  `json:"stageLT,omitempty"`
	StageLTE          *string  `json:"stageLTE,omitempty"`
	StageContains     *string  `json:"stageContains,omitempty"`
	StageHasPrefix    *string  `json:"stageHasPrefix,omitempty"`
	StageHasSuffix    *string  `json:"stageHasSuffix,omitempty"`
	StageEqualFold    *string  `json:"stageEqualFold,omitempty"`
	StageContainsFold *string  `json:"stageContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuditEventWhereInput) AddPredicates(predicates ...predicate.AuditEvent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuditEventWhereInput filter on the AuditEventQuery builder.
func (i *AuditEventWhereInput) Filter(q *AuditEventQuery) (*AuditEventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuditEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuditEventWhereInput is returned in case the AuditEventWhereInput is empty.
var ErrEmptyAuditEventWhereInput = errors.New("ent: empty predicate AuditEventWhereInput")

// P returns a predicate for filtering auditevents.
// An error is returned if the input is empty or invalid.
func (i *AuditEventWhereInput) P() (predicate.AuditEvent, error) {
	var predicates []predicate.AuditEvent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, auditevent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuditEvent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, auditevent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuditEvent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, auditevent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, auditevent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auditevent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auditevent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auditevent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auditevent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auditevent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auditevent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auditevent.IDLTE(*i.IDLTE))
	}
	if i.Raw != nil {
		predicates = append(predicates, auditevent.RawEQ(*i.Raw))
	}
	if i.RawNEQ != nil {
		predicates = append(predicates, auditevent.RawNEQ(*i.RawNEQ))
	}
	if len(i.RawIn) > 0 {
		predicates = append(predicates, auditevent.RawIn(i.RawIn...))
	}
	if len(i.RawNotIn) > 0 {
		predicates = append(predicates, auditevent.RawNotIn(i.RawNotIn...))
	}
	if i.RawGT != nil {
		predicates = append(predicates, auditevent.RawGT(*i.RawGT))
	}
	if i.RawGTE != nil {
		predicates = append(predicates, auditevent.RawGTE(*i.RawGTE))
	}
	if i.RawLT != nil {
		predicates = append(predicates, auditevent.RawLT(*i.RawLT))
	}
	if i.RawLTE != nil {
		predicates = append(predicates, auditevent.RawLTE(*i.RawLTE))
	}
	if i.RawContains != nil {
		predicates = append(predicates, auditevent.RawContains(*i.RawContains))
	}
	if i.RawHasPrefix != nil {
		predicates = append(predicates, auditevent.RawHasPrefix(*i.RawHasPrefix))
	}
	if i.RawHasSuffix != nil {
		predicates = append(predicates, auditevent.RawHasSuffix(*i.RawHasSuffix))
	}
	if i.RawEqualFold != nil {
		predicates = append(predicates, auditevent.RawEqualFold(*i.RawEqualFold))
	}
	if i.RawContainsFold != nil {
		predicates = append(predicates, auditevent.RawContainsFold(*i.RawContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, auditevent.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, auditevent.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, auditevent.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, auditevent.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, auditevent.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, auditevent.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, auditevent.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, auditevent.LevelLTE(*i.LevelLTE))
	}
	if i.LevelContains != nil {
		predicates = append(predicates, auditevent.LevelContains(*i.LevelContains))
	}
	if i.LevelHasPrefix != nil {
		predicates = append(predicates, auditevent.LevelHasPrefix(*i.LevelHasPrefix))
	}
	if i.LevelHasSuffix != nil {
		predicates = append(predicates, auditevent.LevelHasSuffix(*i.LevelHasSuffix))
	}
	if i.LevelEqualFold != nil {
		predicates = append(predicates, auditevent.LevelEqualFold(*i.LevelEqualFold))
	}
	if i.LevelContainsFold != nil {
		predicates = append(predicates, auditevent.LevelContainsFold(*i.LevelContainsFold))
	}
	if i.AuditID != nil {
		predicates = append(predicates, auditevent.AuditIDEQ(*i.AuditID))
	}
	if i.AuditIDNEQ != nil {
		predicates = append(predicates, auditevent.AuditIDNEQ(*i.AuditIDNEQ))
	}
	if len(i.AuditIDIn) > 0 {
		predicates = append(predicates, auditevent.AuditIDIn(i.AuditIDIn...))
	}
	if len(i.AuditIDNotIn) > 0 {
		predicates = append(predicates, auditevent.AuditIDNotIn(i.AuditIDNotIn...))
	}
	if i.AuditIDGT != nil {
		predicates = append(predicates, auditevent.AuditIDGT(*i.AuditIDGT))
	}
	if i.AuditIDGTE != nil {
		predicates = append(predicates, auditevent.AuditIDGTE(*i.AuditIDGTE))
	}
	if i.AuditIDLT != nil {
		predicates = append(predicates, auditevent.AuditIDLT(*i.AuditIDLT))
	}
	if i.AuditIDLTE != nil {
		predicates = append(predicates, auditevent.AuditIDLTE(*i.AuditIDLTE))
	}
	if i.AuditIDContains != nil {
		predicates = append(predicates, auditevent.AuditIDContains(*i.AuditIDContains))
	}
	if i.AuditIDHasPrefix != nil {
		predicates = append(predicates, auditevent.AuditIDHasPrefix(*i.AuditIDHasPrefix))
	}
	if i.AuditIDHasSuffix != nil {
		predicates = append(predicates, auditevent.AuditIDHasSuffix(*i.AuditIDHasSuffix))
	}
	if i.AuditIDEqualFold != nil {
		predicates = append(predicates, auditevent.AuditIDEqualFold(*i.AuditIDEqualFold))
	}
	if i.AuditIDContainsFold != nil {
		predicates = append(predicates, auditevent.AuditIDContainsFold(*i.AuditIDContainsFold))
	}
	if i.Verb != nil {
		predicates = append(predicates, auditevent.VerbEQ(*i.Verb))
	}
	if i.VerbNEQ != nil {
		predicates = append(predicates, auditevent.VerbNEQ(*i.VerbNEQ))
	}
	if len(i.VerbIn) > 0 {
		predicates = append(predicates, auditevent.VerbIn(i.VerbIn...))
	}
	if len(i.VerbNotIn) > 0 {
		predicates = append(predicates, auditevent.VerbNotIn(i.VerbNotIn...))
	}
	if i.VerbGT != nil {
		predicates = append(predicates, auditevent.VerbGT(*i.VerbGT))
	}
	if i.VerbGTE != nil {
		predicates = append(predicates, auditevent.VerbGTE(*i.VerbGTE))
	}
	if i.VerbLT != nil {
		predicates = append(predicates, auditevent.VerbLT(*i.VerbLT))
	}
	if i.VerbLTE != nil {
		predicates = append(predicates, auditevent.VerbLTE(*i.VerbLTE))
	}
	if i.VerbContains != nil {
		predicates = append(predicates, auditevent.VerbContains(*i.VerbContains))
	}
	if i.VerbHasPrefix != nil {
		predicates = append(predicates, auditevent.VerbHasPrefix(*i.VerbHasPrefix))
	}
	if i.VerbHasSuffix != nil {
		predicates = append(predicates, auditevent.VerbHasSuffix(*i.VerbHasSuffix))
	}
	if i.VerbEqualFold != nil {
		predicates = append(predicates, auditevent.VerbEqualFold(*i.VerbEqualFold))
	}
	if i.VerbContainsFold != nil {
		predicates = append(predicates, auditevent.VerbContainsFold(*i.VerbContainsFold))
	}
	if i.UserAgent != nil {
		predicates = append(predicates, auditevent.UserAgentEQ(*i.UserAgent))
	}
	if i.UserAgentNEQ != nil {
		predicates = append(predicates, auditevent.UserAgentNEQ(*i.UserAgentNEQ))
	}
	if len(i.UserAgentIn) > 0 {
		predicates = append(predicates, auditevent.UserAgentIn(i.UserAgentIn...))
	}
	if len(i.UserAgentNotIn) > 0 {
		predicates = append(predicates, auditevent.UserAgentNotIn(i.UserAgentNotIn...))
	}
	if i.UserAgentGT != nil {
		predicates = append(predicates, auditevent.UserAgentGT(*i.UserAgentGT))
	}
	if i.UserAgentGTE != nil {
		predicates = append(predicates, auditevent.UserAgentGTE(*i.UserAgentGTE))
	}
	if i.UserAgentLT != nil {
		predicates = append(predicates, auditevent.UserAgentLT(*i.UserAgentLT))
	}
	if i.UserAgentLTE != nil {
		predicates = append(predicates, auditevent.UserAgentLTE(*i.UserAgentLTE))
	}
	if i.UserAgentContains != nil {
		predicates = append(predicates, auditevent.UserAgentContains(*i.UserAgentContains))
	}
	if i.UserAgentHasPrefix != nil {
		predicates = append(predicates, auditevent.UserAgentHasPrefix(*i.UserAgentHasPrefix))
	}
	if i.UserAgentHasSuffix != nil {
		predicates = append(predicates, auditevent.UserAgentHasSuffix(*i.UserAgentHasSuffix))
	}
	if i.UserAgentEqualFold != nil {
		predicates = append(predicates, auditevent.UserAgentEqualFold(*i.UserAgentEqualFold))
	}
	if i.UserAgentContainsFold != nil {
		predicates = append(predicates, auditevent.UserAgentContainsFold(*i.UserAgentContainsFold))
	}
	if i.RequestTimestamp != nil {
		predicates = append(predicates, auditevent.RequestTimestampEQ(*i.RequestTimestamp))
	}
	if i.RequestTimestampNEQ != nil {
		predicates = append(predicates, auditevent.RequestTimestampNEQ(*i.RequestTimestampNEQ))
	}
	if len(i.RequestTimestampIn) > 0 {
		predicates = append(predicates, auditevent.RequestTimestampIn(i.RequestTimestampIn...))
	}
	if len(i.RequestTimestampNotIn) > 0 {
		predicates = append(predicates, auditevent.RequestTimestampNotIn(i.RequestTimestampNotIn...))
	}
	if i.RequestTimestampGT != nil {
		predicates = append(predicates, auditevent.RequestTimestampGT(*i.RequestTimestampGT))
	}
	if i.RequestTimestampGTE != nil {
		predicates = append(predicates, auditevent.RequestTimestampGTE(*i.RequestTimestampGTE))
	}
	if i.RequestTimestampLT != nil {
		predicates = append(predicates, auditevent.RequestTimestampLT(*i.RequestTimestampLT))
	}
	if i.RequestTimestampLTE != nil {
		predicates = append(predicates, auditevent.RequestTimestampLTE(*i.RequestTimestampLTE))
	}
	if i.StageTimestamp != nil {
		predicates = append(predicates, auditevent.StageTimestampEQ(*i.StageTimestamp))
	}
	if i.StageTimestampNEQ != nil {
		predicates = append(predicates, auditevent.StageTimestampNEQ(*i.StageTimestampNEQ))
	}
	if len(i.StageTimestampIn) > 0 {
		predicates = append(predicates, auditevent.StageTimestampIn(i.StageTimestampIn...))
	}
	if len(i.StageTimestampNotIn) > 0 {
		predicates = append(predicates, auditevent.StageTimestampNotIn(i.StageTimestampNotIn...))
	}
	if i.StageTimestampGT != nil {
		predicates = append(predicates, auditevent.StageTimestampGT(*i.StageTimestampGT))
	}
	if i.StageTimestampGTE != nil {
		predicates = append(predicates, auditevent.StageTimestampGTE(*i.StageTimestampGTE))
	}
	if i.StageTimestampLT != nil {
		predicates = append(predicates, auditevent.StageTimestampLT(*i.StageTimestampLT))
	}
	if i.StageTimestampLTE != nil {
		predicates = append(predicates, auditevent.StageTimestampLTE(*i.StageTimestampLTE))
	}
	if i.Namespace != nil {
		predicates = append(predicates, auditevent.NamespaceEQ(*i.Namespace))
	}
	if i.NamespaceNEQ != nil {
		predicates = append(predicates, auditevent.NamespaceNEQ(*i.NamespaceNEQ))
	}
	if len(i.NamespaceIn) > 0 {
		predicates = append(predicates, auditevent.NamespaceIn(i.NamespaceIn...))
	}
	if len(i.NamespaceNotIn) > 0 {
		predicates = append(predicates, auditevent.NamespaceNotIn(i.NamespaceNotIn...))
	}
	if i.NamespaceGT != nil {
		predicates = append(predicates, auditevent.NamespaceGT(*i.NamespaceGT))
	}
	if i.NamespaceGTE != nil {
		predicates = append(predicates, auditevent.NamespaceGTE(*i.NamespaceGTE))
	}
	if i.NamespaceLT != nil {
		predicates = append(predicates, auditevent.NamespaceLT(*i.NamespaceLT))
	}
	if i.NamespaceLTE != nil {
		predicates = append(predicates, auditevent.NamespaceLTE(*i.NamespaceLTE))
	}
	if i.NamespaceContains != nil {
		predicates = append(predicates, auditevent.NamespaceContains(*i.NamespaceContains))
	}
	if i.NamespaceHasPrefix != nil {
		predicates = append(predicates, auditevent.NamespaceHasPrefix(*i.NamespaceHasPrefix))
	}
	if i.NamespaceHasSuffix != nil {
		predicates = append(predicates, auditevent.NamespaceHasSuffix(*i.NamespaceHasSuffix))
	}
	if i.NamespaceEqualFold != nil {
		predicates = append(predicates, auditevent.NamespaceEqualFold(*i.NamespaceEqualFold))
	}
	if i.NamespaceContainsFold != nil {
		predicates = append(predicates, auditevent.NamespaceContainsFold(*i.NamespaceContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, auditevent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, auditevent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, auditevent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, auditevent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, auditevent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, auditevent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, auditevent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, auditevent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, auditevent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, auditevent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, auditevent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, auditevent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, auditevent.NameContainsFold(*i.NameContainsFold))
	}
	if i.ApiVersion != nil {
		predicates = append(predicates, auditevent.ApiVersionEQ(*i.ApiVersion))
	}
	if i.ApiVersionNEQ != nil {
		predicates = append(predicates, auditevent.ApiVersionNEQ(*i.ApiVersionNEQ))
	}
	if len(i.ApiVersionIn) > 0 {
		predicates = append(predicates, auditevent.ApiVersionIn(i.ApiVersionIn...))
	}
	if len(i.ApiVersionNotIn) > 0 {
		predicates = append(predicates, auditevent.ApiVersionNotIn(i.ApiVersionNotIn...))
	}
	if i.ApiVersionGT != nil {
		predicates = append(predicates, auditevent.ApiVersionGT(*i.ApiVersionGT))
	}
	if i.ApiVersionGTE != nil {
		predicates = append(predicates, auditevent.ApiVersionGTE(*i.ApiVersionGTE))
	}
	if i.ApiVersionLT != nil {
		predicates = append(predicates, auditevent.ApiVersionLT(*i.ApiVersionLT))
	}
	if i.ApiVersionLTE != nil {
		predicates = append(predicates, auditevent.ApiVersionLTE(*i.ApiVersionLTE))
	}
	if i.ApiVersionContains != nil {
		predicates = append(predicates, auditevent.ApiVersionContains(*i.ApiVersionContains))
	}
	if i.ApiVersionHasPrefix != nil {
		predicates = append(predicates, auditevent.ApiVersionHasPrefix(*i.ApiVersionHasPrefix))
	}
	if i.ApiVersionHasSuffix != nil {
		predicates = append(predicates, auditevent.ApiVersionHasSuffix(*i.ApiVersionHasSuffix))
	}
	if i.ApiVersionEqualFold != nil {
		predicates = append(predicates, auditevent.ApiVersionEqualFold(*i.ApiVersionEqualFold))
	}
	if i.ApiVersionContainsFold != nil {
		predicates = append(predicates, auditevent.ApiVersionContainsFold(*i.ApiVersionContainsFold))
	}
	if i.ApiGroup != nil {
		predicates = append(predicates, auditevent.ApiGroupEQ(*i.ApiGroup))
	}
	if i.ApiGroupNEQ != nil {
		predicates = append(predicates, auditevent.ApiGroupNEQ(*i.ApiGroupNEQ))
	}
	if len(i.ApiGroupIn) > 0 {
		predicates = append(predicates, auditevent.ApiGroupIn(i.ApiGroupIn...))
	}
	if len(i.ApiGroupNotIn) > 0 {
		predicates = append(predicates, auditevent.ApiGroupNotIn(i.ApiGroupNotIn...))
	}
	if i.ApiGroupGT != nil {
		predicates = append(predicates, auditevent.ApiGroupGT(*i.ApiGroupGT))
	}
	if i.ApiGroupGTE != nil {
		predicates = append(predicates, auditevent.ApiGroupGTE(*i.ApiGroupGTE))
	}
	if i.ApiGroupLT != nil {
		predicates = append(predicates, auditevent.ApiGroupLT(*i.ApiGroupLT))
	}
	if i.ApiGroupLTE != nil {
		predicates = append(predicates, auditevent.ApiGroupLTE(*i.ApiGroupLTE))
	}
	if i.ApiGroupContains != nil {
		predicates = append(predicates, auditevent.ApiGroupContains(*i.ApiGroupContains))
	}
	if i.ApiGroupHasPrefix != nil {
		predicates = append(predicates, auditevent.ApiGroupHasPrefix(*i.ApiGroupHasPrefix))
	}
	if i.ApiGroupHasSuffix != nil {
		predicates = append(predicates, auditevent.ApiGroupHasSuffix(*i.ApiGroupHasSuffix))
	}
	if i.ApiGroupEqualFold != nil {
		predicates = append(predicates, auditevent.ApiGroupEqualFold(*i.ApiGroupEqualFold))
	}
	if i.ApiGroupContainsFold != nil {
		predicates = append(predicates, auditevent.ApiGroupContainsFold(*i.ApiGroupContainsFold))
	}
	if i.Resource != nil {
		predicates = append(predicates, auditevent.ResourceEQ(*i.Resource))
	}
	if i.ResourceNEQ != nil {
		predicates = append(predicates, auditevent.ResourceNEQ(*i.ResourceNEQ))
	}
	if len(i.ResourceIn) > 0 {
		predicates = append(predicates, auditevent.ResourceIn(i.ResourceIn...))
	}
	if len(i.ResourceNotIn) > 0 {
		predicates = append(predicates, auditevent.ResourceNotIn(i.ResourceNotIn...))
	}
	if i.ResourceGT != nil {
		predicates = append(predicates, auditevent.ResourceGT(*i.ResourceGT))
	}
	if i.ResourceGTE != nil {
		predicates = append(predicates, auditevent.ResourceGTE(*i.ResourceGTE))
	}
	if i.ResourceLT != nil {
		predicates = append(predicates, auditevent.ResourceLT(*i.ResourceLT))
	}
	if i.ResourceLTE != nil {
		predicates = append(predicates, auditevent.ResourceLTE(*i.ResourceLTE))
	}
	if i.ResourceContains != nil {
		predicates = append(predicates, auditevent.ResourceContains(*i.ResourceContains))
	}
	if i.ResourceHasPrefix != nil {
		predicates = append(predicates, auditevent.ResourceHasPrefix(*i.ResourceHasPrefix))
	}
	if i.ResourceHasSuffix != nil {
		predicates = append(predicates, auditevent.ResourceHasSuffix(*i.ResourceHasSuffix))
	}
	if i.ResourceEqualFold != nil {
		predicates = append(predicates, auditevent.ResourceEqualFold(*i.ResourceEqualFold))
	}
	if i.ResourceContainsFold != nil {
		predicates = append(predicates, auditevent.ResourceContainsFold(*i.ResourceContainsFold))
	}
	if i.SubResource != nil {
		predicates = append(predicates, auditevent.SubResourceEQ(*i.SubResource))
	}
	if i.SubResourceNEQ != nil {
		predicates = append(predicates, auditevent.SubResourceNEQ(*i.SubResourceNEQ))
	}
	if len(i.SubResourceIn) > 0 {
		predicates = append(predicates, auditevent.SubResourceIn(i.SubResourceIn...))
	}
	if len(i.SubResourceNotIn) > 0 {
		predicates = append(predicates, auditevent.SubResourceNotIn(i.SubResourceNotIn...))
	}
	if i.SubResourceGT != nil {
		predicates = append(predicates, auditevent.SubResourceGT(*i.SubResourceGT))
	}
	if i.SubResourceGTE != nil {
		predicates = append(predicates, auditevent.SubResourceGTE(*i.SubResourceGTE))
	}
	if i.SubResourceLT != nil {
		predicates = append(predicates, auditevent.SubResourceLT(*i.SubResourceLT))
	}
	if i.SubResourceLTE != nil {
		predicates = append(predicates, auditevent.SubResourceLTE(*i.SubResourceLTE))
	}
	if i.SubResourceContains != nil {
		predicates = append(predicates, auditevent.SubResourceContains(*i.SubResourceContains))
	}
	if i.SubResourceHasPrefix != nil {
		predicates = append(predicates, auditevent.SubResourceHasPrefix(*i.SubResourceHasPrefix))
	}
	if i.SubResourceHasSuffix != nil {
		predicates = append(predicates, auditevent.SubResourceHasSuffix(*i.SubResourceHasSuffix))
	}
	if i.SubResourceEqualFold != nil {
		predicates = append(predicates, auditevent.SubResourceEqualFold(*i.SubResourceEqualFold))
	}
	if i.SubResourceContainsFold != nil {
		predicates = append(predicates, auditevent.SubResourceContainsFold(*i.SubResourceContainsFold))
	}
	if i.Stage != nil {
		predicates = append(predicates, auditevent.StageEQ(*i.Stage))
	}
	if i.StageNEQ != nil {
		predicates = append(predicates, auditevent.StageNEQ(*i.StageNEQ))
	}
	if len(i.StageIn) > 0 {
		predicates = append(predicates, auditevent.StageIn(i.StageIn...))
	}
	if len(i.StageNotIn) > 0 {
		predicates = append(predicates, auditevent.StageNotIn(i.StageNotIn...))
	}
	if i.StageGT != nil {
		predicates = append(predicates, auditevent.StageGT(*i.StageGT))
	}
	if i.StageGTE != nil {
		predicates = append(predicates, auditevent.StageGTE(*i.StageGTE))
	}
	if i.StageLT != nil {
		predicates = append(predicates, auditevent.StageLT(*i.StageLT))
	}
	if i.StageLTE != nil {
		predicates = append(predicates, auditevent.StageLTE(*i.StageLTE))
	}
	if i.StageContains != nil {
		predicates = append(predicates, auditevent.StageContains(*i.StageContains))
	}
	if i.StageHasPrefix != nil {
		predicates = append(predicates, auditevent.StageHasPrefix(*i.StageHasPrefix))
	}
	if i.StageHasSuffix != nil {
		predicates = append(predicates, auditevent.StageHasSuffix(*i.StageHasSuffix))
	}
	if i.StageEqualFold != nil {
		predicates = append(predicates, auditevent.StageEqualFold(*i.StageEqualFold))
	}
	if i.StageContainsFold != nil {
		predicates = append(predicates, auditevent.StageContainsFold(*i.StageContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuditEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return auditevent.And(predicates...), nil
	}
}

// ResourceKindWhereInput represents a where input for filtering ResourceKind queries.
type ResourceKindWhereInput struct {
	Predicates []predicate.ResourceKind  `json:"-"`
	Not        *ResourceKindWhereInput   `json:"not,omitempty"`
	Or         []*ResourceKindWhereInput `json:"or,omitempty"`
	And        []*ResourceKindWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "apiVersion" field predicates.
	ApiVersion             *string  `json:"apiversion,omitempty"`
	ApiVersionNEQ          *string  `json:"apiversionNEQ,omitempty"`
	ApiVersionIn           []string `json:"apiversionIn,omitempty"`
	ApiVersionNotIn        []string `json:"apiversionNotIn,omitempty"`
	ApiVersionGT           *string  `json:"apiversionGT,omitempty"`
	ApiVersionGTE          *string  `json:"apiversionGTE,omitempty"`
	ApiVersionLT           *string  `json:"apiversionLT,omitempty"`
	ApiVersionLTE          *string  `json:"apiversionLTE,omitempty"`
	ApiVersionContains     *string  `json:"apiversionContains,omitempty"`
	ApiVersionHasPrefix    *string  `json:"apiversionHasPrefix,omitempty"`
	ApiVersionHasSuffix    *string  `json:"apiversionHasSuffix,omitempty"`
	ApiVersionEqualFold    *string  `json:"apiversionEqualFold,omitempty"`
	ApiVersionContainsFold *string  `json:"apiversionContainsFold,omitempty"`

	// "namespaced" field predicates.
	Namespaced    *bool `json:"namespaced,omitempty"`
	NamespacedNEQ *bool `json:"namespacedNEQ,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ResourceKindWhereInput) AddPredicates(predicates ...predicate.ResourceKind) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ResourceKindWhereInput filter on the ResourceKindQuery builder.
func (i *ResourceKindWhereInput) Filter(q *ResourceKindQuery) (*ResourceKindQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyResourceKindWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyResourceKindWhereInput is returned in case the ResourceKindWhereInput is empty.
var ErrEmptyResourceKindWhereInput = errors.New("ent: empty predicate ResourceKindWhereInput")

// P returns a predicate for filtering resourcekinds.
// An error is returned if the input is empty or invalid.
func (i *ResourceKindWhereInput) P() (predicate.ResourceKind, error) {
	var predicates []predicate.ResourceKind
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, resourcekind.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ResourceKind, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, resourcekind.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ResourceKind, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, resourcekind.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, resourcekind.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, resourcekind.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, resourcekind.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, resourcekind.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, resourcekind.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, resourcekind.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, resourcekind.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, resourcekind.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, resourcekind.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, resourcekind.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, resourcekind.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, resourcekind.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, resourcekind.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, resourcekind.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, resourcekind.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, resourcekind.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, resourcekind.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, resourcekind.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, resourcekind.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, resourcekind.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, resourcekind.NameContainsFold(*i.NameContainsFold))
	}
	if i.ApiVersion != nil {
		predicates = append(predicates, resourcekind.ApiVersionEQ(*i.ApiVersion))
	}
	if i.ApiVersionNEQ != nil {
		predicates = append(predicates, resourcekind.ApiVersionNEQ(*i.ApiVersionNEQ))
	}
	if len(i.ApiVersionIn) > 0 {
		predicates = append(predicates, resourcekind.ApiVersionIn(i.ApiVersionIn...))
	}
	if len(i.ApiVersionNotIn) > 0 {
		predicates = append(predicates, resourcekind.ApiVersionNotIn(i.ApiVersionNotIn...))
	}
	if i.ApiVersionGT != nil {
		predicates = append(predicates, resourcekind.ApiVersionGT(*i.ApiVersionGT))
	}
	if i.ApiVersionGTE != nil {
		predicates = append(predicates, resourcekind.ApiVersionGTE(*i.ApiVersionGTE))
	}
	if i.ApiVersionLT != nil {
		predicates = append(predicates, resourcekind.ApiVersionLT(*i.ApiVersionLT))
	}
	if i.ApiVersionLTE != nil {
		predicates = append(predicates, resourcekind.ApiVersionLTE(*i.ApiVersionLTE))
	}
	if i.ApiVersionContains != nil {
		predicates = append(predicates, resourcekind.ApiVersionContains(*i.ApiVersionContains))
	}
	if i.ApiVersionHasPrefix != nil {
		predicates = append(predicates, resourcekind.ApiVersionHasPrefix(*i.ApiVersionHasPrefix))
	}
	if i.ApiVersionHasSuffix != nil {
		predicates = append(predicates, resourcekind.ApiVersionHasSuffix(*i.ApiVersionHasSuffix))
	}
	if i.ApiVersionEqualFold != nil {
		predicates = append(predicates, resourcekind.ApiVersionEqualFold(*i.ApiVersionEqualFold))
	}
	if i.ApiVersionContainsFold != nil {
		predicates = append(predicates, resourcekind.ApiVersionContainsFold(*i.ApiVersionContainsFold))
	}
	if i.Namespaced != nil {
		predicates = append(predicates, resourcekind.NamespacedEQ(*i.Namespaced))
	}
	if i.NamespacedNEQ != nil {
		predicates = append(predicates, resourcekind.NamespacedNEQ(*i.NamespacedNEQ))
	}
	if i.Kind != nil {
		predicates = append(predicates, resourcekind.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, resourcekind.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, resourcekind.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, resourcekind.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, resourcekind.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, resourcekind.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, resourcekind.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, resourcekind.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, resourcekind.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, resourcekind.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, resourcekind.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, resourcekind.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, resourcekind.KindContainsFold(*i.KindContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyResourceKindWhereInput
	case 1:
		return predicates[0], nil
	default:
		return resourcekind.And(predicates...), nil
	}
}

// ViewWhereInput represents a where input for filtering View queries.
type ViewWhereInput struct {
	Predicates []predicate.View  `json:"-"`
	Not        *ViewWhereInput   `json:"not,omitempty"`
	Or         []*ViewWhereInput `json:"or,omitempty"`
	And        []*ViewWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ViewWhereInput) AddPredicates(predicates ...predicate.View) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ViewWhereInput filter on the ViewQuery builder.
func (i *ViewWhereInput) Filter(q *ViewQuery) (*ViewQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyViewWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyViewWhereInput is returned in case the ViewWhereInput is empty.
var ErrEmptyViewWhereInput = errors.New("ent: empty predicate ViewWhereInput")

// P returns a predicate for filtering views.
// An error is returned if the input is empty or invalid.
func (i *ViewWhereInput) P() (predicate.View, error) {
	var predicates []predicate.View
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, view.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.View, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, view.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.View, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, view.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, view.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, view.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, view.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, view.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, view.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, view.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, view.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, view.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyViewWhereInput
	case 1:
		return predicates[0], nil
	default:
		return view.And(predicates...), nil
	}
}
